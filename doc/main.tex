\documentclass{article}
\usepackage{xgreek}
\usepackage{xunicode}
\usepackage{xltxtra}
\usepackage{graphicx}
\setmainfont[Mapping=tex-text]{GFS Didot}
\begin{document}
\include{titlepage}
\section{Περιγραφή Αλγορίθμου}
Σε αυτή την ενότητα θα περιγράψουμε τη λειτουργία του αλγορίθμου (top-level
design) που χρησιμοποιεί το πρόγραμμα.

Το πρόγραμμα γενικά υπολογίζει οργανισμούς μέσω γενετικών αλγορίθμων. Κάθε
οργανισμός αποτελείται από ένα γονίδιο, πίνακα με 0 στα σημεία που δεν είναι 
χρωματισμένα και 1 στα σημεία που είναι χρωματισμένα. Επίσης κάθε οργανισμός
έχει μία τιμή αποδοτικότητας (fitness) η οποία προσδιορίζει κατά πόσο ``κοντά''
είναι το γονίδιο ενός οργανισμού με αυτό του επιθυμητού -- τελικού. Η τιμή του
κυμαίνεται μεταξύ 0 και 1, με το 0 να είναι η χειρότερη αποδοτικότητα και το 1 η
καλύτερη.

Αρχικά, δημιουργείται ένας πληθυσμός από οργανισμούς με τυχαία γονίδια.
Υπολογίζεται η αποδοτικότητα για κάθε οργανισμό του πληθυσμού. Στη συνέχεια
επιλέγεται ένα ποσοστό του πληθυσμού με την καλύτερη αποδοτικότητα, επιλέγονται
δύο γονείς, ζευγαρώνουν και προκύπτουν άλλοι δύο οργανισμοί. Οι καινούργιοι
οργανισμοί θεωρούνται η καινούργια γενιά.

Από την καινούργια γενιά επιλέγεται ένα ποσοστό το οποίο θα υποστεί κάποια
μετάλλαξη. Η παραπάνω διαδικασία συνεχίζεται έως ότου κάποιος οργανισμός έχει
αποδοτικότητα 1, δηλαδή συμπίπτει απόλυτα με το επιθυμητό αποτέλεσμα.

\section{Περιγραφή Προγράμματος}
Στην ενότητα αυτή θα περιγράψουμε αναλυτικά την υλοποίηση του παραπάνω
αλγόριθμου. Αρχικά να αναφέρουμε ότι το πρόγραμμα είναι υλοποιημένο στη γλώσσα
\emph{C}. Αποτελείται από τρία αρχεία. Στο αρχείο \emph{color\_graph.c} υπάρχει
η υλοποίηση του γενετικού αλγορίθμου, στο αρχείο \emph{linked\_list.c} υπάρχει η
υλοποίηση των συναρτήσεων μονά συνδεδεμένης λίστα που χρησιμοποιείται από τον
παραπάνω αλγόριθμο. Τέλος στο αρχείο \emph{proto.h} ορίζονται κάποιες μεταβλητές
για ευκολία στην απομνημόνευση, ορίζονται κάποιες δομές δεδομένων που
χρησιμοποιούνται, ένας πίνακας με το επιθυμητό -- τελικό αποτέλεσμα καθώς και τα
πρωτότυπα διάφορων συναρτήσεων.

\subsection{proto.h}
Ας ξεκινήσουμε την περιγραφή από το αρχείο \emph{proto.h} καθώς περιέχει
μεταβλητές και δομές. Αρχικά γίνονται define κάποιες σταθερές για ευκολία στην
απομνημόνευση αλλά και στην εύκολη τροποποίησή τους. Αυτές οι μεταβλητές είναι
το μέγεθος του πίνακα των γονιδίων (\emph{COL, ROW}), ο αριθμός του πληθυσμού
(\emph{POPULATION}), το ποσοστό ανανέωσης του πληθυσμού (\emph{POP\_RATE}), η
μάσκα διασταύρωσης (\emph{HSIZE}), το ποσοστό μετάλλαξης του πληθυσμού
(\emph{MUT\_RATE}) κτλ.

Στη συνέχεια ορίζεται η δομή \emph{Organisms} η οποία αντιπροσωπεύει έναν
οργανισμό. Όπως έχουν ήδη αναφέρει, κάθε οργανισμός αποτελείται από ένα γονίδιο
που είναι ένας πίνακας διαστάσεων \emph{ROW}x\emph{COL} με 0 και 1 (\emph{gene}),
και έναν αριθμό που προσδιορίζει την αποδοτικότητα του (\emph{fitness}).

Έπειτα είναι ορισμένη η δομή \emph{Node} η οποία χρησιμοποιείται από τη
συνδεδεμένη λίστα και αντιπροσωπεύει ένα κόμβο. Κάθε κόμβος αποθηκεύει έναν
οργανισμό (\emph{Organisms}) και ένα δείκτη για τον επόμενο κόμβο.

Επόμενο στη σειρά είναι ένας πίνας διαστάσεων \emph{ROW}x\emph{COL} ο οποίος
περιέχει 0 και 1 σε τέτοια διάταξη ώστε να σχηματίζουν τον γράμμα \textbf{K} με
την προϋπόθεση να μην υπάρχουν 1 σε γειτονικά κελιά. Αυτός ο πίνακας
χρησιμοποιείται για τη σύγκριση και τον υπολογισμό της αποδοτικότητας.

Τέλος υπάρχουν τα πρωτότυπα των συναρτήσεων που χρησιμοποιούνται και στα δύο
αρχεία (\emph{color\_graph.c}, \emph{linked\_list.c}).

\subsection{linked\_list.c}
Στο αρχείο αυτό υπάρχει η υλοποίηση μιας μονά συνδεδεμένης λίστα. Για τον λόγο
αυτό δεν θα το περιγράψουμε αναλυτικά καθώς δεν είναι αυτός ο σκοπός του
μαθήματος.

Η συνάρτηση \emph{push()}, παίρνει ως όρισμα το πρώτο στοιχείο μιας λίστας και
ένα αντικείμενο τύπου \emph{Organisms} και το βάζει στο τέλος της λίστας. Η
συνάρτηση \emph{copy\_list()} παίρνει ως όρισμα τα πρώτα στοιχεία δύο λιστών και
αντιγράφει τα στοιχεία της πρώτης στη δεύτερη. Η \emph{delete()} παίρνει ως
όρισμα το πρώτο στοιχείο μιας λίστας και διαγράφει όλα τα στοιχεία της. Η
συνάρτηση \emph{print\_list()} τυπώνει τα στοιχεία μιας λίστας, χρησιμοποιείται
για debugging. Η συνάρτηση \emph{sort()} παίρνει ως όρισμα το πρώτο στοιχείο
μιας λίστας και την ταξινομεί σε φθίνουσα σειρά. Τέλος η συνάρτηση \emph{size()}
παίρνει ως όρισμα τον πρώτο κόμβο μιας λίστα και επιστρέφει το μέγεθός της.

\subsection{color\_graph.c}
Το αρχείο αυτό είναι το κύριο κομμάτι του προγράμματος καθώς υλοποιεί τον
γενετικό αλγόριθμο. Αρχικά θα περιγράψουμε τις συναρτήσεις που είναι
υλοποιημένες και έπειτα τη λογική που βρίσκεται στη \emph{main()} συνάρτηση. Θα
ξεκινήσουμε την περιγραφή με τη σειρά που βρίσκονται οι συναρτήσεις στο source
file.
\subsubsection{struct Organisms initialize()}
Η συνάρτηση αυτή αρχικοποιεί με 0 και 1 τα γονίδια του αρχικού πληθυσμού.
Δεσμεύει χώρο για ένα struct τύπου \emph{Organisms}. Έπειτα διατρέχει τον
πίνακα gene, παράγεται ένας τυχαίος αριθμός με τη συνάρτηση \emph{random()} και
αν ο τυχαίος αριθμός είναι άρτιος βάζει στο κελί 1 αλλιώς 0. Επίσης αρχικοποιεί
την αποδοτικότητα (fitness) σε 0. Τέλος επιστρέφει αυτό το προσωρινό struct.
\subsubsection{void comp\_fitness(struct Organisms* tmp\_gene)}
Αυτή η συνάρτηση δέχεται ως όρισμα ένα struct τύπου \emph{Organisms}. Σκοπός της
είναι να υπολογίσει το fitness ενός οργανισμού. Διατρέχει τον πίνακα gene του
struct και τον συγκρίνει κελί προς κελί με τον πρότυπο πίνακα που είναι
δηλωμένος στο αρχείο \emph{proto.h}. Εάν κάποιο κελί είναι ίδιο με αυτό του
πρότυπου πίνακα, τότε αυξάνεται ο μετρητής hit. Τελικά διαιρείται με το πλήθος
των κελιών και αποθηκεύεται στο πεδίο fitness του struct που έχει περαστεί σαν
όρισμα.
\subsubsection{void print\_gene(struct Organisms tmp\_gene)}
Η συνάρτηση \emph{print\_gene()} δέχεται ως όρισμα ένα struct τύπου
\emph{Organisms} και τυπώνει τον πίνακα gene. Αν έχει γίνει compile και τρέχει
σε unix τότε τυπώνει με πράσινο τα 1 και με άσπρο τα 0. Αν τρέχει σε Windows
τότε τα τυπώνει όλα με λευκό χρώμα. Επίσης τυπώνει και το fitness του
οργανισμού.
\subsubsection{float total\_fitness(struct Node *head)}
Με τη συνάρτηση \emph{total\_fitness()} υπολογίζουμε την αθροιστική
αποδοτικότητα ενός πληθυσμού με οργανισμούς. Δέχεται ως όρισμα το πρώτο στοιχείο
μιας λίστας, διατρέχει τη λίστα και κάθε φορά προσθέτει στη μεταβλητή
\emph{total\_fit} το fitness. Στο τέλος επιστρέφει τη συνολική αποδοτικότητα.
\subsubsection{struct Organisms pick\_one\_parent(struct Node *head, float total\_fit)}
Η συνάρτηση αυτή χρησιμοποιείται κατά την αναπαραγωγή για την επιλογή των δύο
γονέων. Η επιλογή γίνεται με τον αλγόριθμο της ρουλέτας (Roulette Wheel).
Παίρνει σαν όρισμα μία λίστα με οργανισμούς και τη συνολική αποδοτικότητα τους.
Επιλέγεται ένας αριθμός μεταξύ του 0 και της συνολικής αποδοτικότητας που
χρησιμοποιείται σαν κατώφλι. Διατρέχεται η λίστα και κάθε φορά προστίθεται στη
μεταβλητή \emph{sum} το fitness των οργανισμών. Όταν το \emph{sum} γίνει
μεγαλύτερο από το κατώφλι, σταματάει η επανάληψη και επιλέγεται ο τελευταίος
οργανισμός. Τελικά η συνάρτηση επιστρέφει το struct τύπου \emph{Organisms}.
\subsubsection{void mutate(struct Node **next\_gen)}
Η συνάρτηση αυτή μεταλλάσσει ένα γονίδιο ενός οργανισμού. Δέχεται ως όρισμα ένα
struct τύπου \emph{Node}. Για κάθε μία γραμμή του πίνακα gene του οργανισμού,
επιλέγεται τυχαία μία στήλη, επιλέγεται επίσης τυχαία ένας αριθμός. Αν ο αριθμός
είναι άρτιος, τότε αλλάζει το περιεχόμενο του κελιού από 0 σε 1 και αντίθετα.
\subsubsection{void mate(struct Node **next\_gen, struct Node *mate\_pool)}
Η συνάρτηση αυτή υλοποιεί τον αλγόριθμο αναπαραγωγής με διασταύρωση ενός
σημείου. Δέχεται ως όρισμα μία λίστα που είναι ο πληθυσμός της επόμενης γενιάς
και μία λίστα που περιέχει τους υποψήφιους γονείς. Αρχικά επιλέγονται οι δύο
γονείς με τη συνάρτηση \emph{pick\_one\_parent()}. Δημιουργούνται δύο παιδιά,
στο πρώτο αντιγράφεται το γονίδιο του πρώτου γονέα και στο δεύτερο του δεύτερου
γονέα. Έπειτα γίνεται η διασταύρωση με μάσκα 1111000. Η μάσκα μπορεί να αλλάξει
από το αρχείο \emph{proto.h}. Υπολογίζεται η αποδοτικότητα για κάθε παιδί και
τέλος τοποθετούνται στη λίστα με τον πληθυσμό της επόμενης γενιάς.
\subsubsection{int main(int argc, char *argv[])}
Αυτή είναι κύρια συνάρτηση του προγράμματος. Το πρόγραμμα έχει τρεις λίστες που
αντιπροσωπεύουν τους τρεις πληθυσμούς. Πρώτη λίστα είναι αυτή με τους
οργανισμούς της τρέχουσας γενιάς (\emph{cur\_gen}), δεύτερη είναι η λίστα με
τους διαθέσιμους γονείς (\emph{mate\_pool}) και τέλος η λίστα με τους
οργανισμούς της επόμενης γενιάς (\emph{next\_gen}). Αρχικά λοιπόν καλείται η
συνάρτηση \emph{initialize()} επαναληπτικά και το αποτέλεσμά της τοποθετείται στη
λίστα \emph{cur\_gen}. Μετά για κάθε έναν οργανισμό της παραπάνω λίστας
υπολογίζεται η αποδοτικότητα.

Στη συνέχεια το πρόγραμμα μπαίνει σε ένα βρόγχο μέχρι να βρεθεί κάποιος
οργανισμός που έχει fitness ίσο με 1, δηλαδή να ταιριάζει απόλυτα με το πρότυπο.

Ταξινομείται η λίστα \emph{cur\_gen} και υπολογίζεται το πλήθος του πληθυσμού που 
θα ανανεωθεί σύμφωνα με το \emph{POPULATION} και το \emph{POP\_RATE}.
Αφού έχει ταξινομηθεί η λίστα, οι γονείς που θα επιλεχθούν θα είναι αυτοί με το
μεγαλύτερο fitness.
Επιλέγονται λοιπόν οι γονείς, μπαίνουν στη λίστα \emph{mate\_pool} και γίνεται η
αναπαραγωγή με τη συνάρτηση \emph{mate()}. Τα παιδιά που δημιουργούνται μπαίνουν
στη λίστα \emph{next\_gen}. Έπειτα υπολογίζεται το πλήθος της επόμενης γενιάς
που θα υποστεί μετάλλαξη σύμφωνα με τα \emph{POPULATION} και \emph{MUT\_RATE}
και γίνεται η μετάλλαξη με τη συνάρτηση \emph{mutate()}.

Ταξινομείται σε φθίνουσα σειρά η λίστα \emph{next\_gen}. Με αυτό τον τρόπο ο
οργανισμός με το μεγαλύτερο fitness θα είναι πρώτος. Αν το fitness του πρώτου
οργανισμού είναι ίσο με 1 τότε τυπώνουμε το γονίδιο και τερματίζει το πρόγραμμα.
Σε διαφορετική περίπτωση συνεχίζεται η εκτέλεση του προγράμματος με την επόμενη
επανάληψη. Σε κάθε περίπτωση όμως, στο τέλος κάθε επανάληψης διαγράφεται η
τρέχουσα γενιά (\emph{cur\_gen}), αντιγράφεται η επόμενη γενιά
(\emph{next\_gen}) στην τρέχουσα και διαγράφεται η επόμενη γενιά και η λίστα με
τους γονείς (\emph{mate\_pool}).

Αφού τελειώσει η εκτέλεση του προγράμματος, τυπώνεται το γονίδιο του οργανισμού
που έχει fitness ίσο με 1, μετά από πόσες γενεές ολοκληρώθηκε η διαδικασία και
μετά από πόσο χρόνο σε δευτερόλεπτα.

\section{Εκτέλεση Προγράμματος}
Για να κάνουμε compile τον πηγαίο κώδικα υπάρχει ένα Makefile οπότε αρκεί να
τρέξουμε την εντολή \emph{make}. Για να διαγράψουμε το εκτελέσιμο αρχείο αρκεί
να εκτελέσουμε την εντολή \emph{make clean}. Προαπαιτούμενα είναι να υπάρχει
εγκατεστημένο το
πρόγραμμα \emph{make}. Εναλλακτικά μπορούμε να το κάνουμε compile με τον gcc ή
όποιο άλλο compiler επιθυμούμε. Για τον gcc η εντολή είναι \emph{gcc -o
bin/color\_graph src/*.c}.
Στο Σχήμα \ref{compile} βλέπουμε ένα screenshot από το compilation του προγράμματος
με το πρόγραμμα \emph{make} στο λειτουργικό σύστημα \emph{Debian GNU/Linux}.
\begin{figure}[tbh]
\centering
\includegraphics[scale=0.7]{make.png}
\caption{Compile πηγαίου κώδικα}
\label{compile}
\end{figure}

Στο Σχήμα \ref{running} βλέπουμε ένα screenshot από την εκτέλεση του
προγράμματος. Σε κάθε επανάληψη τυπώνεται η μέγιστη αποδοτικότητα. Στο
τέλος τυπώνεται το γονίδιο με αποδοτικότητα 1, μετά από πόσες γενεές
ολοκληρώθηκε η διαδικασία καθώς και πόσο χρόνο χρειάστηκε.

Κάθε φορά που εκτελούμε το πρόγραμμα τα αποτελέσματα είναι διαφορετικά, πράγμα
που επιβεβαιώνει την τυχαιότητα του προγράμματος. Επίσης ο χρόνος εκτέλεσης και
το πλήθος των γενεών αλλάζει, αν τροποποιήσουμε το μέγεθος του πληθυσμού, το
ποσοστό ανανέωσης του πληθυσμού και το ποσοστό μετάλλαξης από το αρχείο
\emph{proto.h}.

Τα αποτελέσματα του Σχήματος \ref{running} βγήκαν με τις παρακάτω τιμές:\\[2em]
\begin{center}
\begin{tabular}{| c | c |}
\hline
\textbf{Μεταβλητή} & \textbf{Τιμή} \\
\hline
\hline
Μέγεθος πληθυσμού & 3000 \\
\hline
Ποσοστό ανανέωσης & 50\% \\
\hline
Ποσοστό μετάλλαξης & 30\% \\
\hline
\end{tabular}
\end{center}
\begin{figure}[tbh]
\centering
\includegraphics[scale=0.8]{running.png}
\caption{Εκτέλεση προγράμματος}
\label{running}
\end{figure}
\end{document}
